/*
 * -----------------------------------------------------------------------------
 *  Project: Liquor Bot
 *  File: drink_controller.cpp (non‑blocking refactor)
 *  Description: Handles parsing & dispensing – now executed inside a FreeRTOS
 *               task so the main loop stays responsive.
 *
 *  Author: Nathan Hambleton – refactor 16 May 2025 by ChatGPT
 * -----------------------------------------------------------------------------
 */

#include <Arduino.h>
#include <SPI.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include "drink_controller.h"
#include "pin_config.h"
#include "state_manager.h"
#include "aws_manager.h"   // notifyPourResult()

// Forward decls ---------------------------------------------------------------
static void writeNCV7240(uint16_t state);
static void pourDrinkTask(void *param);

// 16‑bit state for two NCV7240 chips
static uint16_t ncvState = 0x0000;

/* -------------------------------------------------------------------------- */
/* INITIALISATION                                                              */
/* -------------------------------------------------------------------------- */
void initDrinkController() {
    SPI.begin(SPI_SCK, SPI_MISO, SPI_MOSI, SPI_CS);
    pinMode(SPI_CS, OUTPUT);
    digitalWrite(SPI_CS, HIGH);

    ncvState = 0x0000;
    writeNCV7240(ncvState);
    Serial.println("NCV7240 SPI initialized, all outputs OFF.");

    pinMode(PUMP_IN1_PIN, OUTPUT);
    pinMode(PUMP_IN2_PIN, OUTPUT);
    digitalWrite(PUMP_IN1_PIN, LOW);
    digitalWrite(PUMP_IN2_PIN, LOW);
}

/* -------------------------------------------------------------------------- */
/*  PUBLIC API – startPourTask()                                               */
/* -------------------------------------------------------------------------- */
void startPourTask(const String &commandStr) {
    /* copy the string onto heap so the task owns it */
    char *buf = strdup(commandStr.c_str());
    if (!buf) {
        Serial.println("strdup failed – OOM?");
        return;
    }
    xTaskCreatePinnedToCore(pourDrinkTask, "PourTask", 8192, buf, 1, nullptr, 1);
}

/* -------------------------------------------------------------------------- */
/*            FREE RTOS TASK – parses + dispenses, then reports result         */
/* -------------------------------------------------------------------------- */
static void pourDrinkTask(void *param) {
    char *raw = static_cast<char *>(param);
    String cmdStr(raw);
    free(raw);

    setState(State::POURING);
    Serial.println("PourTask > started");

    // Parse & dispense -------------------------------------------------------
    std::vector<IngredientCommand> vec = parseDrinkCommand(cmdStr);
    if (vec.empty()) {
        notifyPourResult(false, "empty_command");
        setState(State::IDLE);
        vTaskDelete(nullptr);
    }

    dispenseDrink(vec);

    /* inform AWS manager */
    notifyPourResult(true, nullptr);

    setState(State::IDLE);
    Serial.println("PourTask > finished");
    vTaskDelete(nullptr);
}

/* -------------------------------------------------------------------------- */
/*  (rest of original drink_controller.cpp – UNMODIFIED except final cleanup)  */
/* -------------------------------------------------------------------------- */

// --------------------- NCV7240 SPI WRITE ---------------------
static void writeNCV7240(uint16_t state) {
    uint8_t highByte = (state >> 8) & 0xFF;
    uint8_t lowByte  = state & 0xFF;
    digitalWrite(SPI_CS, LOW);
    SPI.transfer(highByte);
    SPI.transfer(lowByte);
    digitalWrite(SPI_CS, HIGH);
}

// --------------------- HELPER: SET SOLENOID ---------------------
static void setSolenoid(int slot, bool on) {
    int bitIndex = slot - 1;
    if (bitIndex < 0 || bitIndex >= 16) {
        Serial.println("Invalid slot " + String(slot));
        return;
    }
    if (on) ncvState |= (1 << bitIndex);
    else    ncvState &= ~(1 << bitIndex);

    writeNCV7240(ncvState);
}

// --------------------- FLOW RATE EXAMPLE ---------------------
static float flowRate(int numOpen) {
    switch (numOpen) {
        case 1: return 1.0f;
        case 2: return 1.5f;
        case 3: return 1.7f;
        case 4: return 1.8f;
        default: return 0.0f;
    }
}

// --------------------- PARSE LOGIC ---------------------
std::vector<IngredientCommand> parseDrinkCommand(const String &commandStr) {
    std::vector<IngredientCommand> parsedCommand;
    int start = 0;
    while (true) {
        int commaIndex = commandStr.indexOf(',', start);
        String segment;
        if (commaIndex == -1) {
            segment = commandStr.substring(start);
        } else {
            segment = commandStr.substring(start, commaIndex);
        }
        segment.trim();

        if (segment.length() > 0) {
            int firstColon = segment.indexOf(':');
            int secondColon = segment.indexOf(':', firstColon + 1);

            if (firstColon != -1) {
                IngredientCommand cmd;
                
                String slotStr = segment.substring(0, firstColon);
                slotStr.trim();
                cmd.slot = slotStr.toInt();

                if (secondColon != -1) {
                    String amountStr = segment.substring(firstColon + 1, secondColon);
                    amountStr.trim();
                    cmd.amount = amountStr.toFloat();

                    String priorityStr = segment.substring(secondColon + 1);
                    priorityStr.trim();
                    cmd.priority = priorityStr.toInt();
                } else {
                    String amountStr = segment.substring(firstColon + 1);
                    amountStr.trim();
                    cmd.amount = amountStr.toFloat();
                    cmd.priority = 99;
                }

                parsedCommand.push_back(cmd);
            }
        }

        if (commaIndex == -1) break;
        start = commaIndex + 1;
    }
    return parsedCommand;
}

// --------------------- TIME-SLICING PARALLEL LOGIC ---------------------
struct PourState {
    int slot;
    float ouncesNeeded;
    bool done;
};

static void dispenseParallelGroup(std::vector<IngredientCommand> &group) {
    std::vector<PourState> pours;
    for (auto &cmd : group) {
        PourState st;
        st.slot = cmd.slot;
        st.ouncesNeeded = cmd.amount;
        st.done = false;
        if (st.slot < 1 || st.slot > 16) {
            Serial.println("Unknown slot: " + String(cmd.slot));
            st.done = true;
        }
        pours.push_back(st);
    }

    Serial.println("=== Starting parallel group with " + String(pours.size()) + " slots ===");

    const unsigned long stepMs = 50; 
    const float stepSec = 0.05f;  
    bool groupFinished = false;

    while (!groupFinished) {
        // 1) Count how many are still open
        int openCount = 0;
        for (auto &p : pours) {
            if (!p.done && p.ouncesNeeded > 0.0f) {
                openCount++;
            }
        }
        if (openCount == 0) {
            groupFinished = true;
            break;
        }

        // 2) Turn ON all still-active slots, OFF others
        for (auto &p : pours) {
            if (!p.done && p.ouncesNeeded > 0.0f) {
                setSolenoid(p.slot, true); 
            } else {
                setSolenoid(p.slot, false); 
            }
        }

        // 3) totalFlow( openCount )
        float totalFlow = flowRate(openCount);
        float sumNeeded = 0.0f;
        for (auto &p : pours) {
            if (!p.done && p.ouncesNeeded > 0.0f) {
                sumNeeded += p.ouncesNeeded;
            }
        }
        if (sumNeeded < 0.0001f) {
            groupFinished = true;
            break;
        }

        // 4) distribute flow proportionally
        for (auto &p : pours) {
            if (!p.done && p.ouncesNeeded > 0.0f) {
                float fraction = p.ouncesNeeded / sumNeeded; 
                float slotFlow = totalFlow * fraction; 
                float disp = slotFlow * stepSec; 
                p.ouncesNeeded -= disp;
                if (p.ouncesNeeded <= 0.0f) {
                    p.ouncesNeeded = 0.0f;
                    p.done = true;
                }
            }
        }

        delay(stepMs);
    }

    // Turn all off at the end
    for (auto &p : pours) {
        setSolenoid(p.slot, false); 
    }

    Serial.println("=== Parallel group done ===");
}

// --------------------- MAIN DISPENSE FUNCTION ---------------------
void dispenseDrink(std::vector<IngredientCommand> &parsedCommand) {
    // Turn on pump (IN1 HIGH, IN2 LOW in modern code)
    digitalWrite(PUMP_IN1_PIN, HIGH);
    Serial.println("Pump IN1 HIGH (FORWARD).");

    // Sort ascending by priority
    std::sort(parsedCommand.begin(), parsedCommand.end(),
              [](const IngredientCommand &a, const IngredientCommand &b){
                  return a.priority < b.priority;
              });

    int i = 0;
    while (i < (int)parsedCommand.size()) {
        int currentPriority = parsedCommand[i].priority;
        std::vector<IngredientCommand> group;
        while (i < (int)parsedCommand.size() &&
               parsedCommand[i].priority == currentPriority) {
            group.push_back(parsedCommand[i]);
            i++;
        }
        Serial.println("\n>> Priority " + String(currentPriority) + " group <<");
        dispenseParallelGroup(group);
    }

    // Turn off pump
    digitalWrite(PUMP_IN1_PIN, LOW);
    Serial.println("Pump IN1 LOW (OFF).");

    // Call cleanup function
    cleanupDrinkController();
    Serial.println("All priority groups complete. Drink done!");
}

// --------------------- CLEANUP (EMPTY) ---------------------
void cleanupDrinkController() {
    // Currently empty, user can implement final tasks here if needed
}



/*
 * -----------------------------------------------------------------------------
 *  Project: Liquor Bot
 *  File: drink_controller.h  (updated)
 *  Description: Structures & API for non‑blocking drink dispensing.
 * -----------------------------------------------------------------------------
 */

#ifndef DRINK_CONTROLLER_H
#define DRINK_CONTROLLER_H

#include <Arduino.h>
#include <vector>
#include <String>

struct IngredientCommand {
    int   slot;     // 1‑16 (matches solenoid)
    float amount;   // ounces
    int   priority; // lower = earlier group
};

// ---------- Init ----------
void initDrinkController();

// ---------- Parsing ----------
std::vector<IngredientCommand> parseDrinkCommand(const String &commandStr);

// ---------- Execution (blocking – internal use) ----------
void dispenseDrink(std::vector<IngredientCommand> &parsedCommand);

// ---------- NEW: kick off non‑blocking pour ----------
void startPourTask(const String &commandStr);

// ---------- Cleanup ----------
void cleanupDrinkController();

#endif // DRINK_CONTROLLER_H
